<!DOCTYPE html>

<html>

<head>
<style>
#info {
    position: absolute;
    top: 0px;
    width: 100%;
    padding: 10px;
    text-align: center;
    color: #ffff00
}

</style>
</head>

<body> 

<div id="info">hw3  <br/> (use ← ↑ →)</div>
</div>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/KeyboardState.js"></script>
    
</script>
<script> 
var camera, scene, renderer, geometry, material, light, controls;
var signR = 1;
var signL = 1;
var tirex=0,tirez=0;

var pos = new THREE.Vector3(0,0,0), angle = 0, angleL = 0, angleR = 0;
var speed = 5, rotspeed = 0;
var speedR = 0, speedL = 0;
var keyboard = new KeyboardState();
var toycar;
init();
animate();

function init() {

    scene = new THREE.Scene();
    clock = new THREE.Clock();
    
    
    camera = new THREE.PerspectiveCamera(50, window.innerWidth /     window.innerHeight, 1, 10000);
    camera.position.z = 200;
    scene.add(camera);

    THREE.ImageUtils.crossOrigin = '';
    var colormap = THREE.ImageUtils.loadTexture('images/test.png');
    var colormap2 = THREE.ImageUtils.loadTexture('images/ta.jpg');

    
    
    geometry = new THREE.CircleGeometry(6.37, 30);
    material = new THREE.MeshBasicMaterial({
        map: colormap,
        transparent: true,  // for cut-out texture
        side: THREE.DoubleSide
    });
    var meshR = new THREE.Mesh(geometry, material);
    colormap2.wrapS = colormap2.wrapT = THREE.RepeatWrapping; 
	colormap2.repeat.set( 8, 1 );
    var mesh2R = new THREE.Mesh(new THREE.CylinderGeometry(6, 6, 2, 30, 1, true),     // only side
    new THREE.MeshBasicMaterial({
        map: colormap2,
        side: THREE.DoubleSide
    }));
    toycar = new THREE.Object3D();
    scene.add (toycar);
    
    mesh2R.rotation.x = Math.PI / 2;
    meshR.position.set(0, 0, 1);
    mesh0R = meshR.clone();
    mesh0R.position.set(0, 0, -1);
    mesh0R.rotation.y = Math.PI;
    
    tireR  = new THREE.Object3D();
    tireR.add (meshR);
    tireR.add(mesh0R);
    tireR.add(mesh2R);
    tireR.position.set (0,6,7);
    toycar.add(tireR);
    
    
    
    ////////
    var meshL = new THREE.Mesh(geometry, material);
    var mesh2L = new THREE.Mesh(new THREE.CylinderGeometry(6, 6, 2, 30, 1, true),     // only side
    new THREE.MeshBasicMaterial({
        map: colormap2,
        side: THREE.DoubleSide
    }));
    
    
    mesh2L.rotation.x = Math.PI / 2;
    meshL.position.set(0, 0, 1);
    mesh0L = meshL.clone();
    mesh0L.position.set(0, 0, -1);
    mesh0L.rotation.y = Math.PI;
    
    tireL = new THREE.Object3D();
    
    tireL.add (meshL);
    tireL.add(mesh0L);
    tireL.add(mesh2L);
    tireL.position.set (0,6,-7);
    toycar.add(tireL);
    
    
    

    light = new THREE.PointLight(0xffffff);
    light.position.set(100, 300, 200);
    scene.add(light);

    var gridXZ = new THREE.GridHelper(100, 10);
    gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
    scene.add(gridXZ);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);

    controls = new THREE.OrbitControls(camera, renderer.domElement);

    document.body.appendChild(renderer.domElement);
}

function animate() {
    
   /* var dt = clock.getDelta();
    var spd =10;
    var spdR = 10;
    var spdL = 10;
    
    angle+=1;
    angle%=360;
    
    //angleR+=1;
    angleR%=360;
    
    //angleL+=1;
    angleL%=360;
    
    tirex = Math.cos(90/180*Math.PI)*spd*dt;
    tirez = Math.sin(90/180*Math.PI)*spd*dt;
    
    //if (tireR.position.x > 50 || tireR.position.x < -50) spdR *= -1;
    tireR.position.x =tirex;
    tireR.position.z =tirez;
    tireR.rotation.z -= spdR*dt/5;
    tireR.rotation.y = -(90/180*Math.PI);
    
    //if (tireL.position.x > 50 || tireL.position.x < -50) velL *= -1;
   /* tireL.position.x =tirex+ Math.cos(0-angle/180*Math.PI)*spdL*dt;
    tireL.position.z =tirez+ Math.sin(0-angle/180*Math.PI)*spdL*dt;
    tireL.rotation.z -= spdL*dt/5;
    tireL.rotation.y = -(angleL/180*Math.PI);*/
    
    var dt = clock.getDelta();
	
	var dir = new THREE.Vector3(1,0,0);

	angle += rotspeed*dt;
	dir.multiplyScalar (dt*speed).applyAxisAngle (new THREE.Vector3(0,1,0), -angle);

	pos.add (dir); 	
	
	if (toycar != undefined) { 
		toycar.scale.set (1,1,1);
		toycar.position.set (pos.z, pos.y, pos.x);
		toycar.rotation.y = angle+Math.PI/2;
		
		tireL.rotation.z += speedL*dt/5;;
		
		
		tireR.rotation.z += speedR*dt/5;
		
		
		
	}
    
    
    requestAnimationFrame(animate);
    update();
    render();
}

function myclamp(x,lo,hi)
{
	if (x < lo) return lo;
	if (x > hi) return hi;
	return x;
}

function update()
{
	controls.update();
	keyboard.update();         

	if ( keyboard.pressed("left") )
	{ 
		angleL -= 0.3;
		angleR -= 0.05;
		speedL += 0.5; 
		
	}
	if ( keyboard.pressed("right") )
	{
		angleL -= 0.05;
		angleR -= 0.3;
		speedR += 0.5; 
		
	}
	if ( keyboard.pressed("up") )  
	{	
		angleL -= 0.05;
		angleR -= 0.05;
		speedL += 0.5;
		speedR += 0.5;
	}

	speedL *= 0.95;
	speedR *= 0.95;

	console.log ("L: " + speedL + "; R: " + speedR);
	

	speedL = myclamp (speedL, 0, 20);
	speedR = myclamp (speedR, 0, 20);
	
	speed = (speedL + speedR)/2;
	rotspeed = (speedL - speedR)/20;
	
}


function render() {
    renderer.render(scene, camera);
}
</script>
</body>

</html>