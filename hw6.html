<html>

<head>
<style>
#info {
    position: absolute;
    top: 0px;
    width: 100%;
    padding: 10px;
    text-align: center;
    color: #ffff00
}
body {
    overflow: hidden;
}

</style>
</head>

<body> 

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>     
</script>
<script id="myVertexShader" type="x-shader/x-vertex">
    varying vec2 vUv;
    void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        vUv = uv;
    }
</script>
<script id="myFragmentShader" type="x-shader/x-fragment">
    uniform sampler2D texture;
    varying vec2 vUv;

    void main() {
        vec4 color = texture2D(texture, vUv);
        if (color.b > 0.85) discard;
        else gl_FragColor = vec4(.2, .2, .2, 0.) + color;
    }
</script>
<script type="x-shader/x-fragment" id="fragmentShaderDepth">
    uniform sampler2D texture;
    varying vec2 vUv;

    vec4 pack_depth(const in float depth) {
        const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
        const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
        vec4 res = fract(depth * bit_shift);
        res -= res.xxyz * bit_mask;
        return res;
    }

    void main() {
        vec4 pixel = texture2D(texture, vUv);
        if (pixel.b > 0.85) discard;
        gl_FragData[0] = pack_depth(gl_FragCoord.z);
    }
</script>
<script>
var camera, scene, renderer, light, controls;
var sceneRTT, rtTexture, teapot;
var angle = 0;
var i,j;
init();
animate();

function init() {
    sceneRTT = new THREE.Scene();
    light = new THREE.PointLight(0xffffff);
    light.position.set(0, 300, 200);
    sceneRTT.add(light);
	
	var jsonLoader = new THREE.JSONLoader();
    jsonLoader.load("images/test.obj", function (geometry) {
        teapot = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({
            color: 0xff0000
        }));
        teapot.scale.set(32, 32, 32);
        sceneRTT.add(teapot);
    });
	
	var plane = new THREE.PlaneBufferGeometry(150, 150);
    rttmaterial = new THREE.ShaderMaterial({
        side: THREE.DoubleSide,
		
        uniforms: {
            texture: {
                type: "t",
                value: rtTexture
            }
        },
        vertexShader: document.getElementById('myVertexShader').textContent,
        fragmentShader: document.getElementById('myFragmentShader').textContent
    });
	
	mash = new THREE.Mesh(plane, rttmaterial);
    mash.position.set(0, 20, 0);

    rtTexture = new THREE.WebGLRenderTarget(
    window.innerWidth, window.innerHeight, {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.NearestFilter,
        format: THREE.RGBFormat
    });
	
    scene = new THREE.Scene();
    renderer = new THREE.WebGLRenderer({
        antialias: true
    });
	
	var ambientLight = new THREE.AmbientLight(0x555555);
    scene.add(ambientLight);
	
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);

    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.y = 80;
    camera.position.z = 400;
    camera.lookAt(new THREE.Vector3(0, 0, 0));
    controls = new THREE.OrbitControls(camera, renderer.domElement);
    document.body.appendChild(renderer.domElement);

     for (i = -2; i <= 2; i++)
        for (j = -2; j <= 2; j++) {
            var mashij = mash.clone();
            mashij.position.set(50 * i, 0, 50 * j);
			mashij.name="billboard";
            scene.add(mashij);
         
			renderer.shadowMapEnabled = true;
			renderer.shadowMapType = THREE.PCFShadowMap;

			mashij.castShadow = true;
			mashij.customDepthMaterial = new THREE.ShaderMaterial({
				side: THREE.DoubleSide,
				uniforms: {
					texture: {
						type: 't',
						value: rtTexture
					}
				},
			vertexShader: document.getElementById('myVertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShaderDepth').textContent
    });
        }
    spotLight = new THREE.SpotLight(0xffffff, 1);
    spotLight.position.set(300, 300, 300);
    spotLight.angle = Math.PI / 3;
    spotLight.castShadow = true;
    spotLight.shadowCameraFov = spotLight.angle / Math.PI * 180;
    scene.add(spotLight);
	flo	 = THREE.ImageUtils.loadTexture('images/wood1.jpg');
	
    var floor_geom = new THREE.PlaneGeometry(400,400);
	var floor_mat = new THREE.MeshLambertMaterial ({
			map: flo,
            side: THREE.DoubleSide
        });
	floor = new THREE.Mesh (floor_geom, floor_mat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);
    floor.receiveShadow = true;
}

function animate() {
    
    controls.update();
    angle += 0.02;
    if (teapot !== undefined)
		teapot.rotation.y = angle;

	scene.traverse(function (mesh){
		if(mesh instanceof(THREE.Mesh) && mesh.name=="billboard"){
				rotateBillboard(mesh);
			}
		});
    requestAnimationFrame(animate);
    render();
}

function render() {
    
    renderer.setClearColor(0x0000ff);
    renderer.render(sceneRTT, camera, rtTexture, true);

    renderer.setClearColor(0x888888);
    renderer.render(scene, camera);
}

function rotateBillboard (mesh)
{
    var b = mesh.position.clone();
    var rotaxis = new THREE.Vector3();
    var v, yhat, n;
    
    v = camera.position.clone();
    yhat = new THREE.Vector3(0, 1, 0);
    n = new THREE.Vector3(0, 0, 1);

    v.subVectors(v, b); 
    v.sub(yhat.clone().multiplyScalar(v.dot(yhat)));
    v.normalize(); 

    rotangle = Math.acos(v.dot(n));
    rotaxis.crossVectors(n, v);
    if (rotaxis.dot(yhat) < 0) rotangle *= -1;

    mesh.rotation.y = rotangle;
}

</script>

</body>

</html>